<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>xmap</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>

<style type="text/css">
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
span.underline{text-decoration: underline;}
div.column{display: inline-block; vertical-align: top; width: 50%;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
</style>



<style type="text/css">
code {
white-space: pre;
}
.sourceCode {
overflow: visible;
}
</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
{ counter-reset: source-line 0; }
pre.numberSource code > span
{ position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
{ content: counter(source-line);
position: relative; left: -1em; text-align: right; vertical-align: baseline;
border: none; display: inline-block;
-webkit-touch-callout: none; -webkit-user-select: none;
-khtml-user-select: none; -moz-user-select: none;
-ms-user-select: none; user-select: none;
padding: 0 4px; width: 4em;
color: #aaaaaa;
}
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa; padding-left: 4px; }
div.sourceCode
{ }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } 
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.at { color: #7d9029; } 
code span.bn { color: #40a070; } 
code span.bu { color: #008000; } 
code span.cf { color: #007020; font-weight: bold; } 
code span.ch { color: #4070a0; } 
code span.cn { color: #880000; } 
code span.co { color: #60a0b0; font-style: italic; } 
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.do { color: #ba2121; font-style: italic; } 
code span.dt { color: #902000; } 
code span.dv { color: #40a070; } 
code span.er { color: #ff0000; font-weight: bold; } 
code span.ex { } 
code span.fl { color: #40a070; } 
code span.fu { color: #06287e; } 
code span.im { color: #008000; font-weight: bold; } 
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } 
code span.kw { color: #007020; font-weight: bold; } 
code span.op { color: #666666; } 
code span.ot { color: #007020; } 
code span.pp { color: #bc7a00; } 
code span.sc { color: #4070a0; } 
code span.ss { color: #bb6688; } 
code span.st { color: #4070a0; } 
code span.va { color: #19177c; } 
code span.vs { color: #4070a0; } 
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } 
</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    var j = 0;
    while (j < rules.length) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") {
        j++;
        continue;
      }
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') {
        j++;
        continue;
      }
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>




<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">xmap</h1>



<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" tabindex="-1"></a><span class="fu">library</span>(xmap)</span>
<span id="cb1-2"><a href="#cb1-2" tabindex="-1"></a><span class="fu">library</span>(dplyr)</span></code></pre></div>
<div id="the-crossmaps-framework" class="section level2">
<h2>The Crossmaps Framework</h2>
<p>This package is an implementation of the Crossmaps Framework for
unified <em>specification, verification, implementation and
documentation</em> of operations involved in transforming aggregate
statistics between related measurement instruments (e.g. classification
codes).</p>
<p>The framework conceptualises the aggregation of redistribution of
numeric masses between related taxonomic structures as an operation
which applies a graph-based representation of mapping and redistribution
logic between source and target keys (the <em>crossmap</em>), to
conformable key-value pairs (<em>shared mass array</em>).</p>
<p>A <em>crossmap</em> specifies:</p>
<ul>
<li>related pairs of source and target key (e.g. states in country)</li>
<li>weights between 0 and 1 for distributing numeric mass between each
related pair of source and target keys (e.g. 25% of country-level GDP
-&gt; state-A)</li>
</ul>
<p>A <em>shared mass array</em> is a collection of key-value pairs,
where the values form a shared numeric and the keys are parts of a
shared conceptual whole (e.g. GDP by state -&gt; country)</p>
<p>The crossmaps framework is an alternative approach to data
transformation that removes the need for bespoke code to handle data
preparation involving many-to-one or one-to-many operations.</p>
<p>TODO: ADD crossmaps before/after image.</p>
<p>The framework gives rise to assertions on input <em>crossmap</em> and
<em>shared mass arrays</em> which ensure the transformations are valid,
and implemented exactly as specified. Valid and well-documented
transformation workflows should have the following properties:</p>
<ul>
<li>preservation of the shared total mass before and after
transformation. For example, country level GDP should remain constant
regardless of disaggregation method or granularity (e.g. state vs
county)</li>
<li>explicit handling of missing values, without any implicit missing
value arithemtic (e.g. aggregating ‘missing’ state-level mass to
country-level by treating the values as zeros via expressions like
<code>sum(state, na.rm = TRUE)</code>)</li>
</ul>
<p>See the related paper, <a href="https://arxiv.org/abs/2406.14163"><em>A Unified Statistical And
Computational Framework For Ex-Post Harmonisation Of Aggregate
Statistics</em></a>, for further details on the conditions which
guarantee the above properties. This package implements workflow
warnings and errors to ensure relevant conditions are met.</p>
</div>
<div id="the-xmap-workflow" class="section level2">
<h2>The <code>{xmap}</code> workflow</h2>
</div>
<div id="example-country-state-aggregation-and-redistributions" class="section level2">
<h2>Example: Country-State Aggregation and Redistributions</h2>
<p>Consider data transformations which reference relations between
hierarchical administrative regions.</p>
<p>In the following example, we use some basic data manipulation
operations from <code>{dplyr}</code> to generate mapping weights for
transforming numeric mass (e.g. GDP):</p>
<ul>
<li>aggregating from state-level to country-level,</li>
<li>redistributing from country-level to state-level</li>
</ul>
</div>
<div id="aggregation-coverage-and-missing-value-checks" class="section level2">
<h2>Aggregation, Coverage, and Missing Value Checks</h2>
<p>For aggregation, we use unit weights:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" tabindex="-1"></a>aus_state_agg_links <span class="ot">&lt;-</span> mock<span class="sc">$</span>aus_state_pairs <span class="sc">|&gt;</span></span>
<span id="cb2-2"><a href="#cb2-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">ones =</span> <span class="dv">1</span><span class="dt">L</span>)</span></code></pre></div>
<p>Links are validated when coercing them into crossmaps, and some
additional information about the transformation is computed (i.e. how
many unique keys are in the source and target taxonomies):</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" tabindex="-1"></a>(agg_xmap <span class="ot">&lt;-</span> aus_state_agg_links <span class="sc">|&gt;</span></span>
<span id="cb3-2"><a href="#cb3-2" tabindex="-1"></a>  <span class="fu">as_xmap_tbl</span>(<span class="at">from =</span> state, <span class="at">to =</span> ctry, <span class="at">weight_by =</span> ones)</span>
<span id="cb3-3"><a href="#cb3-3" tabindex="-1"></a>)</span>
<span id="cb3-4"><a href="#cb3-4" tabindex="-1"></a><span class="co">#&gt; # A crossmap tibble: 8 × 3</span></span>
<span id="cb3-5"><a href="#cb3-5" tabindex="-1"></a><span class="co">#&gt; # with unique keys:  [8] state -&gt; [1] ctry</span></span>
<span id="cb3-6"><a href="#cb3-6" tabindex="-1"></a><span class="co">#&gt;   .from$state .to$ctry .weight_by$ones</span></span>
<span id="cb3-7"><a href="#cb3-7" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;              &lt;int&gt;</span></span>
<span id="cb3-8"><a href="#cb3-8" tabindex="-1"></a><span class="co">#&gt; 1 AU-ACT      AUS                    1</span></span>
<span id="cb3-9"><a href="#cb3-9" tabindex="-1"></a><span class="co">#&gt; 2 AU-NSW      AUS                    1</span></span>
<span id="cb3-10"><a href="#cb3-10" tabindex="-1"></a><span class="co">#&gt; 3 AU-NT       AUS                    1</span></span>
<span id="cb3-11"><a href="#cb3-11" tabindex="-1"></a><span class="co">#&gt; 4 AU-QLD      AUS                    1</span></span>
<span id="cb3-12"><a href="#cb3-12" tabindex="-1"></a><span class="co">#&gt; 5 AU-SA       AUS                    1</span></span>
<span id="cb3-13"><a href="#cb3-13" tabindex="-1"></a><span class="co">#&gt; 6 AU-TAS      AUS                    1</span></span>
<span id="cb3-14"><a href="#cb3-14" tabindex="-1"></a><span class="co">#&gt; 7 AU-VIC      AUS                    1</span></span>
<span id="cb3-15"><a href="#cb3-15" tabindex="-1"></a><span class="co">#&gt; 8 AU-WA       AUS                    1</span></span></code></pre></div>
<p>The unit weights represent a “transfer” of 100% of the source values
indexed by <code>.from</code> keys to the target <code>.to</code>
keys.</p>
<p>Let’s generate some dummy state-level data to apply our aggregation
to:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">1395</span>)</span>
<span id="cb4-2"><a href="#cb4-2" tabindex="-1"></a>(aus_state_data <span class="ot">&lt;-</span> mock<span class="sc">$</span>aus_state_pairs <span class="sc">|&gt;</span></span>
<span id="cb4-3"><a href="#cb4-3" tabindex="-1"></a>  <span class="fu">mutate</span>(</span>
<span id="cb4-4"><a href="#cb4-4" tabindex="-1"></a>    <span class="at">gdp =</span> <span class="fu">runif</span>(<span class="fu">n</span>(), <span class="dv">100</span>, <span class="dv">2000</span>),</span>
<span id="cb4-5"><a href="#cb4-5" tabindex="-1"></a>    <span class="at">ref =</span> <span class="dv">100</span></span>
<span id="cb4-6"><a href="#cb4-6" tabindex="-1"></a>  ))</span>
<span id="cb4-7"><a href="#cb4-7" tabindex="-1"></a><span class="co">#&gt; # A tibble: 8 × 4</span></span>
<span id="cb4-8"><a href="#cb4-8" tabindex="-1"></a><span class="co">#&gt;   ctry  state    gdp   ref</span></span>
<span id="cb4-9"><a href="#cb4-9" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt; &lt;chr&gt;  &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" tabindex="-1"></a><span class="co">#&gt; 1 AUS   AU-ACT 1626.   100</span></span>
<span id="cb4-11"><a href="#cb4-11" tabindex="-1"></a><span class="co">#&gt; 2 AUS   AU-NSW 1244.   100</span></span>
<span id="cb4-12"><a href="#cb4-12" tabindex="-1"></a><span class="co">#&gt; 3 AUS   AU-NT   703.   100</span></span>
<span id="cb4-13"><a href="#cb4-13" tabindex="-1"></a><span class="co">#&gt; 4 AUS   AU-QLD  239.   100</span></span>
<span id="cb4-14"><a href="#cb4-14" tabindex="-1"></a><span class="co">#&gt; 5 AUS   AU-SA  1388.   100</span></span>
<span id="cb4-15"><a href="#cb4-15" tabindex="-1"></a><span class="co">#&gt; 6 AUS   AU-TAS 1192.   100</span></span>
<span id="cb4-16"><a href="#cb4-16" tabindex="-1"></a><span class="co">#&gt; 7 AUS   AU-VIC 1535.   100</span></span>
<span id="cb4-17"><a href="#cb4-17" tabindex="-1"></a><span class="co">#&gt; 8 AUS   AU-WA   306.   100</span></span></code></pre></div>
<p>Now to transform / aggregate our data:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" tabindex="-1"></a>(aus_ctry_data <span class="ot">&lt;-</span> aus_state_data <span class="sc">|&gt;</span></span>
<span id="cb5-2"><a href="#cb5-2" tabindex="-1"></a>  <span class="fu">apply_xmap</span>(</span>
<span id="cb5-3"><a href="#cb5-3" tabindex="-1"></a>    <span class="at">.xmap =</span> agg_xmap,</span>
<span id="cb5-4"><a href="#cb5-4" tabindex="-1"></a>    <span class="at">values_from =</span> <span class="fu">c</span>(gdp, ref),</span>
<span id="cb5-5"><a href="#cb5-5" tabindex="-1"></a>    <span class="at">keys_from =</span> state</span>
<span id="cb5-6"><a href="#cb5-6" tabindex="-1"></a>  )</span>
<span id="cb5-7"><a href="#cb5-7" tabindex="-1"></a>)</span>
<span id="cb5-8"><a href="#cb5-8" tabindex="-1"></a><span class="co">#&gt; # A tibble: 1 × 3</span></span>
<span id="cb5-9"><a href="#cb5-9" tabindex="-1"></a><span class="co">#&gt;   ctry    gdp   ref</span></span>
<span id="cb5-10"><a href="#cb5-10" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span id="cb5-11"><a href="#cb5-11" tabindex="-1"></a><span class="co">#&gt; 1 AUS   8233.   800</span></span></code></pre></div>
<p>What happens if our crossmap was missing instructions for multiple
states?</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" tabindex="-1"></a><span class="do">## dropping links</span></span>
<span id="cb6-2"><a href="#cb6-2" tabindex="-1"></a>agg_xmap[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, ]</span>
<span id="cb6-3"><a href="#cb6-3" tabindex="-1"></a><span class="co">#&gt; # A crossmap tibble: 3 × 3</span></span>
<span id="cb6-4"><a href="#cb6-4" tabindex="-1"></a><span class="co">#&gt; # with unique keys:  [3] state -&gt; [1] ctry</span></span>
<span id="cb6-5"><a href="#cb6-5" tabindex="-1"></a><span class="co">#&gt;   .from$state .to$ctry .weight_by$ones</span></span>
<span id="cb6-6"><a href="#cb6-6" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;       &lt;chr&gt;              &lt;int&gt;</span></span>
<span id="cb6-7"><a href="#cb6-7" tabindex="-1"></a><span class="co">#&gt; 1 AU-ACT      AUS                    1</span></span>
<span id="cb6-8"><a href="#cb6-8" tabindex="-1"></a><span class="co">#&gt; 2 AU-NSW      AUS                    1</span></span>
<span id="cb6-9"><a href="#cb6-9" tabindex="-1"></a><span class="co">#&gt; 3 AU-NT       AUS                    1</span></span>
<span id="cb6-10"><a href="#cb6-10" tabindex="-1"></a></span>
<span id="cb6-11"><a href="#cb6-11" tabindex="-1"></a><span class="do">## will lead to an error!</span></span>
<span id="cb6-12"><a href="#cb6-12" tabindex="-1"></a><span class="fu">apply_xmap</span>(</span>
<span id="cb6-13"><a href="#cb6-13" tabindex="-1"></a>  <span class="at">.data =</span> aus_state_data,</span>
<span id="cb6-14"><a href="#cb6-14" tabindex="-1"></a>  <span class="at">.xmap =</span> agg_xmap[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, ],</span>
<span id="cb6-15"><a href="#cb6-15" tabindex="-1"></a>  <span class="at">values_from =</span> <span class="fu">c</span>(gdp, ref),</span>
<span id="cb6-16"><a href="#cb6-16" tabindex="-1"></a>  <span class="at">keys_from =</span> state</span>
<span id="cb6-17"><a href="#cb6-17" tabindex="-1"></a>)</span>
<span id="cb6-18"><a href="#cb6-18" tabindex="-1"></a><span class="co">#&gt; Error in `apply_xmap()`:</span></span>
<span id="cb6-19"><a href="#cb6-19" tabindex="-1"></a><span class="co">#&gt; ✖ One or more keys in `.data` do not have corresponding links in `.xmap`</span></span>
<span id="cb6-20"><a href="#cb6-20" tabindex="-1"></a><span class="co">#&gt; ℹ Add missing links to `.xmap` or subset `.data`</span></span></code></pre></div>
<p>This error prevents the accidental dropping of observations by
incomplete specification of transformation instruction.</p>
<p>To inspect and remedy this issue, we can use
<code>diagnose_apply_xmap()</code> to find out which keys in
<code>.data</code> are not covered by the <code>.xmap</code>:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" tabindex="-1"></a><span class="fu">diagnose_apply_xmap</span>(</span>
<span id="cb7-2"><a href="#cb7-2" tabindex="-1"></a>  <span class="at">.data =</span> aus_state_data,</span>
<span id="cb7-3"><a href="#cb7-3" tabindex="-1"></a>  <span class="at">.xmap =</span> agg_xmap[<span class="dv">1</span><span class="sc">:</span><span class="dv">3</span>, ],</span>
<span id="cb7-4"><a href="#cb7-4" tabindex="-1"></a>  <span class="at">values_from =</span> <span class="fu">c</span>(gdp, ref)</span>
<span id="cb7-5"><a href="#cb7-5" tabindex="-1"></a>)</span>
<span id="cb7-6"><a href="#cb7-6" tabindex="-1"></a><span class="co">#&gt; Warning: ✖ Found 5 keys in `.data` without corresponding match in `.xmap$.from`</span></span>
<span id="cb7-7"><a href="#cb7-7" tabindex="-1"></a><span class="co">#&gt; See .$not_covered</span></span>
<span id="cb7-8"><a href="#cb7-8" tabindex="-1"></a><span class="co">#&gt; $not_covered</span></span>
<span id="cb7-9"><a href="#cb7-9" tabindex="-1"></a><span class="co">#&gt; # A tibble: 5 × 2</span></span>
<span id="cb7-10"><a href="#cb7-10" tabindex="-1"></a><span class="co">#&gt;   .key$state .value$gdp  $ref</span></span>
<span id="cb7-11"><a href="#cb7-11" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;           &lt;dbl&gt; &lt;dbl&gt;</span></span>
<span id="cb7-12"><a href="#cb7-12" tabindex="-1"></a><span class="co">#&gt; 1 AU-QLD           239.   100</span></span>
<span id="cb7-13"><a href="#cb7-13" tabindex="-1"></a><span class="co">#&gt; 2 AU-SA           1388.   100</span></span>
<span id="cb7-14"><a href="#cb7-14" tabindex="-1"></a><span class="co">#&gt; 3 AU-TAS          1192.   100</span></span>
<span id="cb7-15"><a href="#cb7-15" tabindex="-1"></a><span class="co">#&gt; 4 AU-VIC          1535.   100</span></span>
<span id="cb7-16"><a href="#cb7-16" tabindex="-1"></a><span class="co">#&gt; 5 AU-WA            306.   100</span></span></code></pre></div>
<p>Missing values will also be flagged to encourage explicit handling of
missing values before the <code>apply_xmap()</code> mapping
transformation:</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" tabindex="-1"></a><span class="co"># add some `NA`</span></span>
<span id="cb8-2"><a href="#cb8-2" tabindex="-1"></a>aus_state_data_na <span class="ot">&lt;-</span> aus_state_data</span>
<span id="cb8-3"><a href="#cb8-3" tabindex="-1"></a>aus_state_data_na[<span class="fu">c</span>(<span class="dv">1</span>, <span class="dv">3</span>, <span class="dv">5</span>), <span class="st">&quot;gdp&quot;</span>] <span class="ot">&lt;-</span> <span class="cn">NA</span></span>
<span id="cb8-4"><a href="#cb8-4" tabindex="-1"></a></span>
<span id="cb8-5"><a href="#cb8-5" tabindex="-1"></a><span class="fu">apply_xmap</span>(</span>
<span id="cb8-6"><a href="#cb8-6" tabindex="-1"></a>  <span class="at">.data =</span> aus_state_data_na,</span>
<span id="cb8-7"><a href="#cb8-7" tabindex="-1"></a>  <span class="at">.xmap =</span> agg_xmap,</span>
<span id="cb8-8"><a href="#cb8-8" tabindex="-1"></a>  <span class="at">values_from =</span> gdp,</span>
<span id="cb8-9"><a href="#cb8-9" tabindex="-1"></a>  <span class="at">keys_from =</span> state</span>
<span id="cb8-10"><a href="#cb8-10" tabindex="-1"></a>)</span>
<span id="cb8-11"><a href="#cb8-11" tabindex="-1"></a><span class="co">#&gt; Error in `apply_xmap()`:</span></span>
<span id="cb8-12"><a href="#cb8-12" tabindex="-1"></a><span class="co">#&gt; ✖ Missing values not allowed in `.data` columns: gdp</span></span>
<span id="cb8-13"><a href="#cb8-13" tabindex="-1"></a><span class="co">#&gt; ℹ Remove or replace missing values.</span></span></code></pre></div>
</div>
<div id="redistribution-valid-weights-and-preserving-totals" class="section level2">
<h2>Redistribution, valid weights and preserving totals</h2>
<p>For redistributing, we can choose any weights as long as the sum of
weights on outgoing links from each source key totals one (or
<code>dplyr::near()</code> enough). This ensures that we only split
source values into percentage parts that sum to 100%.</p>
<p>A common naive strategy is to distribute equally amongst related
target keys:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" tabindex="-1"></a>mock<span class="sc">$</span>aus_state_pairs <span class="sc">|&gt;</span></span>
<span id="cb9-2"><a href="#cb9-2" tabindex="-1"></a>  <span class="fu">group_by</span>(ctry) <span class="sc">|&gt;</span></span>
<span id="cb9-3"><a href="#cb9-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">equal =</span> <span class="dv">1</span> <span class="sc">/</span> <span class="fu">n_distinct</span>(state)) <span class="sc">|&gt;</span></span>
<span id="cb9-4"><a href="#cb9-4" tabindex="-1"></a>  <span class="fu">ungroup</span>() <span class="sc">|&gt;</span></span>
<span id="cb9-5"><a href="#cb9-5" tabindex="-1"></a>  <span class="fu">as_xmap_tbl</span>(<span class="at">from =</span> ctry, <span class="at">to =</span> state, <span class="at">weight_by =</span> equal)</span>
<span id="cb9-6"><a href="#cb9-6" tabindex="-1"></a><span class="co">#&gt; # A crossmap tibble: 8 × 3</span></span>
<span id="cb9-7"><a href="#cb9-7" tabindex="-1"></a><span class="co">#&gt; # with unique keys:  [1] ctry -&gt; [8] state</span></span>
<span id="cb9-8"><a href="#cb9-8" tabindex="-1"></a><span class="co">#&gt;   .from$ctry .to$state .weight_by$equal</span></span>
<span id="cb9-9"><a href="#cb9-9" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;      &lt;chr&gt;                &lt;dbl&gt;</span></span>
<span id="cb9-10"><a href="#cb9-10" tabindex="-1"></a><span class="co">#&gt; 1 AUS        AU-ACT               0.125</span></span>
<span id="cb9-11"><a href="#cb9-11" tabindex="-1"></a><span class="co">#&gt; 2 AUS        AU-NSW               0.125</span></span>
<span id="cb9-12"><a href="#cb9-12" tabindex="-1"></a><span class="co">#&gt; 3 AUS        AU-NT                0.125</span></span>
<span id="cb9-13"><a href="#cb9-13" tabindex="-1"></a><span class="co">#&gt; 4 AUS        AU-QLD               0.125</span></span>
<span id="cb9-14"><a href="#cb9-14" tabindex="-1"></a><span class="co">#&gt; 5 AUS        AU-SA                0.125</span></span>
<span id="cb9-15"><a href="#cb9-15" tabindex="-1"></a><span class="co">#&gt; 6 AUS        AU-TAS               0.125</span></span>
<span id="cb9-16"><a href="#cb9-16" tabindex="-1"></a><span class="co">#&gt; 7 AUS        AU-VIC               0.125</span></span>
<span id="cb9-17"><a href="#cb9-17" tabindex="-1"></a><span class="co">#&gt; 8 AUS        AU-WA                0.125</span></span></code></pre></div>
<p>If we use invalid weights, such as unit weights,
<code>as_xmap_tbl()</code> will error:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb10-1"><a href="#cb10-1" tabindex="-1"></a>mock<span class="sc">$</span>aus_state_pairs <span class="sc">|&gt;</span></span>
<span id="cb10-2"><a href="#cb10-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">ones =</span> <span class="dv">1</span>) <span class="sc">|&gt;</span></span>
<span id="cb10-3"><a href="#cb10-3" tabindex="-1"></a>  <span class="fu">as_xmap_tbl</span>(<span class="at">from =</span> ctry, <span class="at">to =</span> state, <span class="at">weight_by =</span> ones)</span>
<span id="cb10-4"><a href="#cb10-4" tabindex="-1"></a><span class="co">#&gt; Error in `xmap_tbl()`:</span></span>
<span id="cb10-5"><a href="#cb10-5" tabindex="-1"></a><span class="co">#&gt; ! Incomplete mapping weight_by found for some links</span></span>
<span id="cb10-6"><a href="#cb10-6" tabindex="-1"></a><span class="co">#&gt; ✖ The total outgoing `.weight_by` for some `.from` nodes are not near enough to</span></span>
<span id="cb10-7"><a href="#cb10-7" tabindex="-1"></a><span class="co">#&gt;   1</span></span>
<span id="cb10-8"><a href="#cb10-8" tabindex="-1"></a><span class="co">#&gt; ℹ Modify `.weight_by` or adjust `tol` and try again.</span></span>
<span id="cb10-9"><a href="#cb10-9" tabindex="-1"></a><span class="co">#&gt; ℹ Use `diagnose_xmap_tbl() for more information.</span></span></code></pre></div>
<p>Except in the case of one-to-one mappings, crossmaps are generally
lateral (one-way), and have different weights in each direction.</p>
<p>A more sophisticated strategy for generating weights is to use
reference information. For example, we can use population shares to
redistribute GDP between states:</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" tabindex="-1"></a>(split_xmap_pop <span class="ot">&lt;-</span> mock<span class="sc">$</span>aus_state_pop_df <span class="sc">|&gt;</span></span>
<span id="cb11-2"><a href="#cb11-2" tabindex="-1"></a>  <span class="fu">group_by</span>(ctry) <span class="sc">|&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">pop_share =</span> pop <span class="sc">/</span> <span class="fu">sum</span>(pop)) <span class="sc">|&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" tabindex="-1"></a>  <span class="fu">ungroup</span>() <span class="sc">|&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" tabindex="-1"></a>  <span class="fu">as_xmap_tbl</span>(</span>
<span id="cb11-6"><a href="#cb11-6" tabindex="-1"></a>    <span class="at">from =</span> ctry, <span class="at">to =</span> state, <span class="at">weight_by =</span> pop_share</span>
<span id="cb11-7"><a href="#cb11-7" tabindex="-1"></a>  ))</span>
<span id="cb11-8"><a href="#cb11-8" tabindex="-1"></a><span class="co">#&gt; # A crossmap tibble: 8 × 3</span></span>
<span id="cb11-9"><a href="#cb11-9" tabindex="-1"></a><span class="co">#&gt; # with unique keys:  [1] ctry -&gt; [8] state</span></span>
<span id="cb11-10"><a href="#cb11-10" tabindex="-1"></a><span class="co">#&gt;   .from$ctry .to$state .weight_by$pop_share</span></span>
<span id="cb11-11"><a href="#cb11-11" tabindex="-1"></a><span class="co">#&gt;   &lt;chr&gt;      &lt;chr&gt;                    &lt;dbl&gt;</span></span>
<span id="cb11-12"><a href="#cb11-12" tabindex="-1"></a><span class="co">#&gt; 1 AUS        AU-ACT                 0.0176 </span></span>
<span id="cb11-13"><a href="#cb11-13" tabindex="-1"></a><span class="co">#&gt; 2 AUS        AU-NSW                 0.314  </span></span>
<span id="cb11-14"><a href="#cb11-14" tabindex="-1"></a><span class="co">#&gt; 3 AUS        AU-NT                  0.00965</span></span>
<span id="cb11-15"><a href="#cb11-15" tabindex="-1"></a><span class="co">#&gt; 4 AUS        AU-QLD                 0.205  </span></span>
<span id="cb11-16"><a href="#cb11-16" tabindex="-1"></a><span class="co">#&gt; 5 AUS        AU-SA                  0.0701 </span></span>
<span id="cb11-17"><a href="#cb11-17" tabindex="-1"></a><span class="co">#&gt; 6 AUS        AU-TAS                 0.0220 </span></span>
<span id="cb11-18"><a href="#cb11-18" tabindex="-1"></a><span class="co">#&gt; 7 AUS        AU-VIC                 0.255  </span></span>
<span id="cb11-19"><a href="#cb11-19" tabindex="-1"></a><span class="co">#&gt; 8 AUS        AU-WA                  0.107</span></span></code></pre></div>
<p>Let’s redistribute the country level data we aggregated above back to
state level using our calcuted population weights:</p>
<div class="sourceCode" id="cb12"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" tabindex="-1"></a>aus_state_data2 <span class="ot">&lt;-</span> aus_ctry_data <span class="sc">|&gt;</span></span>
<span id="cb12-2"><a href="#cb12-2" tabindex="-1"></a>  <span class="fu">mutate</span>(<span class="at">ref =</span> <span class="dv">10000</span>) <span class="sc">|&gt;</span></span>
<span id="cb12-3"><a href="#cb12-3" tabindex="-1"></a>  <span class="fu">apply_xmap</span>(split_xmap_pop,</span>
<span id="cb12-4"><a href="#cb12-4" tabindex="-1"></a>    <span class="at">values_from =</span> <span class="fu">c</span>(gdp, ref),</span>
<span id="cb12-5"><a href="#cb12-5" tabindex="-1"></a>    <span class="at">keys_from =</span> ctry</span>
<span id="cb12-6"><a href="#cb12-6" tabindex="-1"></a>  )</span></code></pre></div>
<p>Note: that the values in the transformed <code>ref</code> column do
not exactly match the float values in <code>.weight_by$pop_share</code>
used as transformation weights. This is due to floating point
inaccuracies. Over larger transformations with more keys, this may
result in slight mismatches between the total numeric mass before and
after transformation.</p>
<pre><code>#&gt; # A tibble: 8 × 5
#&gt;   .from$ctry state     gdp    ref .weight_by$pop_share
#&gt;   &lt;chr&gt;      &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt;                &lt;dbl&gt;
#&gt; 1 AUS        AU-ACT  145.   176.               0.0176 
#&gt; 2 AUS        AU-NSW 2584.  3139.               0.314  
#&gt; 3 AUS        AU-NT    79.4   96.5              0.00965
#&gt; 4 AUS        AU-QLD 1687.  2049.               0.205  
#&gt; 5 AUS        AU-SA   577.   701.               0.0701 
#&gt; 6 AUS        AU-TAS  181.   220.               0.0220 
#&gt; 7 AUS        AU-VIC 2096.  2546.               0.255  
#&gt; 8 AUS        AU-WA   883.  1072.               0.107</code></pre>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
